searchState.loadedDescShard("jwt_compact", 0, "Minimalistic JSON web token (JWT) implementation with …\nJWT signing algorithm.\nAutomatically implemented extensions of the <code>Algorithm</code> …\nAlgorithm mentioned in the token header differs from …\nSignature for a certain JWT signing <code>Algorithm</code>.\nByte representation of a SHA-1 or SHA-256 digest.\nToken claims cannot be serialized into CBOR.\nIdentifier of a claim in <code>Claims</code>.\nClaims encoded in a token.\nToken claims cannot be serialized into JSON.\nErrors that can occur during token creation.\nA structure with no fields that can be used as a type …\n<code>exp</code> claim (expiration time).\nToken has expired.\nJWT header.\nToken header cannot be serialized.\nCannot decode base64.\nToken signature has failed verification.\nToken signature has invalid byte length.\nToken has invalid structure.\nConstant byte length of signatures supported by the …\nConstant byte length of signatures supported by the …\nToken claims cannot be deserialized from CBOR.\nToken claims cannot be deserialized from JSON.\nToken header cannot be parsed.\nToken signature is malformed.\nClaim requested during validation is not present in the …\n<code>nbf</code> claim (valid not before).\nToken is not yet valid as per <code>nbf</code> claim.\nErrors that may occur during token parsing.\nAlgorithm that uses a custom name when creating and …\nSignature produced by the algorithm.\n<code>Token</code> together with the validated token signature.\nKey used when issuing new tokens.\nOpaque string representation of the thumbprint. It is the …\nRepresentation of a X.509 certificate thumbprint (<code>x5t</code> and …\nTime-related options for token creation and validation.\nToken with validated integrity.\nContent type mentioned in the token header is not …\nParsed, but unvalidated token.\nErrors that can occur during token validation.\nValidator for a certain signing <code>Algorithm</code> associated with …\nKey used when verifying tokens. May coincide with …\nImplementations of JWT signing / verification algorithms. …\nGets the integrity algorithm used to secure the token.\nRepresents this signature as bytes.\nSHA-1 thumbprint of the X.509 certificate for the signing …\nSHA-256 thumbprint of the X.509 certificate for the …\nURL of the X.509 certificate for the signing key. This …\nGets token claims.\nSource of the current timestamps.\nCreates a new token with CBOR-encoded claims and …\nCustom claims.\nDeserializes claims from this token without checking token …\nCreates an empty claims instance.\nCreates an empty header.\nExpiration time of the token.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates options based on the specified time leeway. The …\nGets the token header.\nGets token header.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts this token to an owned form.\nSplits the <code>Token</code> into the respective <code>Header</code> and <code>Claims</code> …\nTime of token issuance.\nBasic support of JSON Web Keys (JWK).\nIdentifier of the key that has signed the token. This …\nURL of the JSON Web Key Set containing the key that has …\nLeeway to use during validation.\nReturns the name of this algorithm, as mentioned in the <code>alg</code>…\nCreates options based on the specified time leeway and …\nCreates a new instance with the provided custom claims.\nCreates a header with the specified custom fields.\nCreates an untrusted token from a string. This is a …\nCreates a renamed algorithm.\nMinimum time at which token is valid.\nOther fields encoded in the header. These fields may be …\nPrelude to neatly import all necessary stuff from the …\nSets the <code>expiration</code> claim so that the token has the …\nAtomically sets <code>issued_at</code> and <code>expiration</code> claims: first to …\nSets the <code>nbf</code> claim.\nSigns a <code>message</code> with the <code>signing_key</code>.\nToken signature.\nReturns signature bytes from the token. These bytes are <strong>not</strong>…\nCreates a new token and serializes it to string.\nVerified token.\nApplication-specific token type. This field is renamed to …\nAttempts to restore a signature from a byte slice. This …\nValidates the token integrity against a verifying key …\nValidates the expiration claim.\nValidates the token integrity against the provided …\nValidates the token integrity against a verifying key …\nValidates the token integrity against the provided …\nValidates the maturity time (<code>nbf</code> claim).\nCreates a JWT validator for the specified verifying key …\nVerifies the <code>message</code> against the <code>signature</code> and …\nSets the <code>certificate_sha1_thumbprint</code> field for this header.\nSets the <code>certificate_thumbprint</code> field for this header.\nSets the <code>certificate_url</code> field for this header.\nSets the <code>key_id</code> field for this header.\nSets the <code>key_set_url</code> field for this header.\nSets the <code>token_type</code> field for this header.\nActual algorithm in the token.\nActual signature length.\nExpected algorithm name.\nExpected signature length.\nDecryption error.\nIntegrity algorithm using digital signatures on the …\n<code>ES256</code> signing algorithm. Implements elliptic curve digital …\nAlgorithm implementing elliptic curve digital signatures …\n4096 bits.\n<code>HS256</code> signing algorithm.\nSigning / verifying key for <code>HS256</code> algorithm. Zeroed on …\nSignature produced by the <code>Hs256</code> algorithm.\n<code>HS384</code> signing algorithm.\nSigning / verifying key for <code>HS384</code> algorithm. Zeroed on …\nSignature produced by the <code>Hs384</code> algorithm.\n<code>HS512</code> signing algorithm.\nSigning / verifying key for <code>HS512</code> algorithm. Zeroed on …\nSignature produced by the <code>Hs512</code> algorithm.\nInput must be hashed.\nInternal error.\nInvalid arguments.\nInvalid coefficient.\nInvalid exponent.\nInvalid modulus.\nInvalid padding length.\nInvalid padding scheme.\nInvalid prime value.\nLabel too long.\nMaximum value of the public exponent <code>e</code>.\nMaximum size of the modulus <code>n</code> in bits.\nMinimum value of the public exponent <code>e</code>.\nMessage too long.\nBit length of an RSA key modulus (aka RSA key length).\nError type returned when a conversion of an integer into …\nModulus too large.\nNumber of primes must be 2 or greater.\nPKCS#1 error.\nPKCS#8 error.\nPublic exponent too large.\nPublic exponent too small.\nIntegrity algorithm using RSA digital signatures.\nError types\nErrors that can occur when parsing an <code>Rsa</code> algorithm from a …\nRepresents a whole RSA key, public and private parts.\nRepresents the public part of an RSA key.\nRSA signature.\nGeneric container for secret bytes, which can be either …\nSigning key for a specific signature cryptosystem. In the …\nWrapper around a JWT algorithm signalling that it supports …\nWrapper around keys allowing to enforce key strength …\n3072 bits.\nToo few primes of a given length to generate an RSA key.\n2048 bits. This is the minimum recommended key length as …\nVerification error.\nVerifying key for a specific signature cryptosystem. In …\nError type used for fallible conversion into a <code>StrongKey</code>.\nReturns the key as raw bytes.\nReturns the key as raw bytes.\nConverts this length to the numeric value.\nCreates secret bytes from a borrowed slice.\nClears precomputed values by setting to None\nCompute CRT coefficient: <code>(1/q) mod p</code>.\nDecrypt the given message.\nDecrypt the given message.\nEncrypt the given message.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs an RSA key pair from individual components:\nConstructs an RSA key pair from its two primes p and q.\nConstructs an RSA key pair from its primes.\nCreates a key from <code>raw</code> bytes. Returns an error if the …\nCreates a key from <code>raw</code> bytes. Returns an error if the …\nGenerates a random key using a cryptographically secure …\nGenerates a random key using a cryptographically secure …\nGenerates a random key using a cryptographically secure …\nGenerates a new key pair with the specified modulus bit …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the wrapped value.\nCreates a key from the specified <code>bytes</code>.\nCreates a key from the specified <code>bytes</code>.\nCreates a key from the specified <code>bytes</code>.\nCreates a new algorithm instance. This is a (moderately) …\nCreate a new public key from its components.\nGenerate a new Rsa key pair of the given bit size using …\nCreate a new public key, bypassing checks around the …\nGenerate a new RSA key pair of the given bit size and the …\nCreate a new public key from its components.\nCreates secret bytes from an owned <code>Vec</code>.\nPerforms some calculations to speed up private key …\nRSA with SHA-256 and PSS padding.\nRSA with SHA-384 and PSS padding.\nRSA with SHA-512 and PSS padding.\nRSA with SHA-256 and PKCS#1 v1.5 padding.\nRSA with SHA-384 and PKCS#1 v1.5 padding.\nRSA with SHA-512 and PKCS#1 v1.5 padding.\nSign the given digest.\nSign the given digest using the provided <code>rng</code>, which is …\nConverts this private key to a public key.\nGet the public key from the private key, cloning <code>n</code> and <code>e</code>.\nConverts a signing key to a verification key.\nPerforms basic sanity checks on the key. Returns <code>Ok(())</code> if …\nVerify a signed message.\nRSA based on the specified algorithm name.\nCreates an algorithm instance with the algorithm name …\nCustom error specific to a crypto backend.\nPublic or private key in an ECDSA crypto system. …\nPublic or private key in an ECDSA crypto system. Has <code>kty</code> …\nBasic JWK functionality: (de)serialization and creating …\nErrors that can occur when transforming a <code>JsonWebKey</code> into …\nGeneric asymmetric keypair. Corresponds to the <code>OKP</code> value …\nGeneric asymmetric keypair. This key type is used e.g. for …\nType of a <code>JsonWebKey</code>.\nSigning and verifying keys do not match.\nRequired field is absent from JWK.\nPublic or private RSA key. Corresponds to the <code>RSA</code> value of …\nPublic or private RSA key. Has <code>kty</code> field set to <code>RSA</code>.\nBlock for an additional prime factor in <code>RsaPrivateParts</code>.\nParts of <code>JsonWebKey::Rsa</code> that are specific to private keys.\nSymmetric key. Corresponds to the <code>oct</code> value of the <code>kty</code> …\nGeneric symmetric key, e.g. for <code>HS256</code> algorithm. Has <code>kty</code> …\nKey type (the <code>kty</code> field) is not as expected.\nJWK field has an unexpected byte length.\nJWK field has an unexpected value.\nFactor CRT coefficient (<code>t</code>).\nFactor CRT exponent (<code>d</code>).\nCreates a <code>Custom</code> error variant.\nPrime factor (<code>r</code>).\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if this key can be used for signing (has …\nGets the type of this key.\nOther prime factors.\nFirst factor CRT exponent (<code>dp</code>).\nFirst prime factor (<code>p</code>).\nSecond prime factor (<code>q</code>).\nPrivate exponent (<code>d</code>).\nCRT coefficient of the second factor (<code>qi</code>).\nSecond factor CRT exponent (<code>dq</code>).\nComputes a thumbprint of this JWK. The result complies …\nReturns a copy of this key with parts not necessary for …\nCurve name (<code>crv</code>), such as <code>secp256k1</code>.\nCurve name (<code>crv</code>), such as <code>Ed25519</code>.\nKey modulus (<code>n</code>).\nPrivate RSA parameters. Only present for private keys.\nPublic exponent (<code>e</code>).\nSecret scalar (<code>d</code>); not present for public keys.\nBytes representing this key.\nSecret key (<code>d</code>). For Ed25519, this is the seed.\n<code>x</code> coordinate of the curve point.\nPublic key. For Ed25519, this is the standard 32-byte …\n<code>y</code> coordinate of the curve point.\nActual key type.\nActual value of the field.\nActual byte length of the field.\nExpected key type.\nExpected value of the field.\nExpected byte length of the field.\nField name.\nField name.")